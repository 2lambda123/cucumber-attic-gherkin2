#include "gherkin_parser.h"
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>


#define LEN(AT, FPC) (FPC - buffer - parser->AT)
#define MARK(M,FPC) (parser->M = (FPC) - buffer)
#define PTR_TO(F) (buffer + parser->F)

/** Machine **/

%%{
  machine parser;
 
  action begin_content {
		MARK(content_start, fpc);
    parser->current_line = parser->line_number;
  }
  
  action begin_pystring_content {
    MARK(content_start, fpc);
  }

  action start_pystring {
    parser->current_line = parser->line_number;
    parser->start_col = fpc - buffer - parser->last_newline;
  }
 
  action store_pystring_content {
    if (parser->store_pystring_content != NULL) {
      int len = LEN(content_start, PTR_TO(final_newline));
      if (len >= 0) { // not an empty pystring
        parser->store_pystring_content(parser->listener, parser->start_col, PTR_TO(content_start), LEN(content_start, PTR_TO(final_newline)), parser->current_line); 
      }
      else { // Empty pystring
        parser->store_pystring_content(parser->listener, parser->start_col, PTR_TO(content_start), 0, parser->current_line); 
      } 
    }
  } 
 
  action store_feature_content {
    if (parser->store_feature_content != NULL) {
			parser->store_feature_content(parser->listener, PTR_TO(keyword_start), LEN(keyword_start, PTR_TO(keyword_end)), PTR_TO(content_start), LEN(content_start, PTR_TO(content_end)), parser->current_line);
      if(parser->content_end != 0) {
        fpc = PTR_TO(content_end - 1);
      }
      parser->content_end = 0;
    }
  }
  
  action store_background_content {
    if (parser->store_background_content != NULL) {
			parser->store_background_content(parser->listener, PTR_TO(keyword_start), LEN(keyword_start, PTR_TO(keyword_end)), PTR_TO(content_start), LEN(content_start, PTR_TO(content_end)), parser->current_line);
      if(parser->content_end != 0) {
        fpc = PTR_TO(content_end - 1);
      }
      parser->content_end = 0;
    }
  }
  
  action store_scenario_content {
    if (parser->store_scenario_content != NULL) {
			parser->store_scenario_content(parser->listener, PTR_TO(keyword_start), LEN(keyword_start, PTR_TO(keyword_end)), PTR_TO(content_start), LEN(content_start, PTR_TO(content_end)), parser->current_line);
      if(parser->content_end != 0) {
        fpc = PTR_TO(content_end - 1);
      }
      parser->content_end = 0;
    }
  }
  
  action store_scenario_outline_content {
    if (parser->store_scenario_outline_content != NULL) {
			parser->store_scenario_outline_content(parser->listener, PTR_TO(keyword_start), LEN(keyword_start, PTR_TO(keyword_end)), PTR_TO(content_start), LEN(content_start, PTR_TO(content_end)), parser->current_line);
      if(parser->content_end != 0) {
        fpc = PTR_TO(content_end - 1);
      }
      parser->content_end = 0;
    }
  }
  
  action store_examples_content {
    if (parser->store_examples_content != NULL) {
			parser->store_examples_content(parser->listener, PTR_TO(keyword_start), LEN(keyword_start, PTR_TO(keyword_end)), PTR_TO(content_start), LEN(content_start, PTR_TO(content_end)), parser->current_line);
      if(parser->content_end != 0) {
        fpc = PTR_TO(content_end - 1);
      }
      parser->content_end = 0;
    }
  }
  
  action store_step_content {
    if (parser->store_step_content != NULL) {
			parser->store_step_content(parser->listener, PTR_TO(keyword_start), LEN(keyword_start, PTR_TO(keyword_end)), PTR_TO(content_start), LEN(content_start, fpc), parser->current_line);
    }
  }
  
  action store_comment_content {
    if(parser->store_comment_content != NULL) {
      parser->store_comment_content(parser->listener, PTR_TO(content_start), LEN(content_start,fpc), parser->line_number);
    }
  }
  
  action store_tag_content {
    if (parser->store_tag_content != NULL) {
      parser->store_tag_content(parser->listener, PTR_TO(content_start), LEN(content_start, fpc), parser->line_number);
    }
  }
  
  action inc_line_number {
    parser->line_number += 1;
    MARK(final_newline, fpc);
  }
    
  action last_newline {
    MARK(last_newline, fpc + 1);
  }
 
  action start_keyword {
    if(parser->mark == 0) {
      MARK(mark, fpc);
    }
  }
  
  action end_keyword {
    MARK(keyword_end, fpc);
    MARK(keyword_start, PTR_TO(mark));
    MARK(content_start, fpc + 1);
    parser->mark = 0;
  }
  
  action next_keyword_start {
    MARK(content_end, fpc);
  }

  action start_table {
  }
  
  action begin_cell_content {
  }

  action store_cell_content {
  }

  action start_row {
  }  

  action store_row {
  }

  action store_table {
  }

  action end_table {
    // printf("end_table\n");
  }
 
  action end_feature {
//
//  We need to swap out the first \r?\n after last_newline with a \0
//
    if (cs < parser_first_final) {
      if (parser->raise_parser_error != NULL) {
//        if (LEN(last_newline, PTR_TO(final_newline)) > 0) {
          parser->raise_parser_error(parser->listener, PTR_TO(last_newline), 5, 5); //parser->line_number);
//        } else {
           // There will be cases where last_newline and/or final_newline aren't set when we end up in an error state...what then? 
//        }
      }
    }
  }

  include parser_common "parser_common.<%= i18n_language %>.rl";   

}%%

/** Data **/
%% write data;

int parser_init(parser *parser) {
  int cs = 0;
  %% write init;
  parser->cs = cs;
  parser->content_start = 0;
  parser->content_end = 0;
  parser->content_len = 0;
  parser->mark = 0;
  parser->nread = 0;
  parser->field_len = 0;
  parser->keyword_start = 0;
  parser->keyword_end = 0;
  parser->next_keyword_start = 0;
  parser->line_number = 1;
  parser->last_newline = 0;
  parser->final_newline = 0;
  parser->start_col = 0;
  
  return(1);
}

/** exec **/
size_t parser_scan(parser *parser, const char *buffer, size_t len, size_t off) {
  const char *p, *pe, *eof;
  int cs = parser->cs;

  assert(off <= len && "offset past end of buffer");

  p = buffer+off;
  pe = buffer+len;
  eof = pe;

  assert(*pe == '\0' && "pointer does not end on NUL");
  assert(pe - p == len - off && "pointers aren't same distance");

  %% write exec;

  parser->cs = cs;
  parser->nread += p - (buffer + off);
  
  assert(p <= pe && "buffer overflow after parsing execute");
  assert(parser->nread <= len && "nread longer than length");
  assert(parser->content_start <= len && "content starts after buffer end");
  assert(parser->mark < len && "mark is after buffer end");
  assert(parser->field_len <= len && "field has length longer than the whole buffer");
//  assert(parser->field_start < len && "field starts after buffer end");

// Reset parser (by re-initializing the whole thing) 
  parser_init(parser);
  
  return(parser_has_error(parser));
}

int parser_has_error(parser *parser) {
  return parser->cs == parser_error;
}
