#include "gherkin_parser.h"
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>


#define LEN(AT, FPC) (FPC - buffer - parser->AT)
#define MARK(M,FPC) (parser->M = (FPC) - buffer)
#define PTR_TO(F) (buffer + parser->F)

/** Machine **/

%%{
  machine parser;
  
  action begin_content {
    printf("begin_content\n");
  }
  
  action init_pystring {
    printf("init_pystring\n");
  }
  
  action start_pystring {
    printf("start_pystring\n");
  }
  
  action start_line {
    printf("start_line\n");
  }
  
  action end_line {
    printf("end_line\n");
  }
  
  action store_feature_content {
    printf("store_feature_content\n");
  }
  
  action store_background_content {
    printf("store_background_content\n");
  }
  
  action store_scenario_content {
    printf("store_scenario_content\n");
  }
  
  action store_scenario_outline_content {
    printf("store_scenario_outline_content\n");
  }
  
  action store_examples_content {
    printf("store_examples_content\n");
  }
  
  action store_step_content {
    printf("store_step_content\n");
  }
  
  action store_comment_content {
    if(parser->store_comment_content != NULL) {
      parser->store_comment_content(parser->listener, parser->data, PTR_TO(keyword_start), LEN(keyword_start,fpc), parser->line_number);
    }
    printf("store_comment_content\n");
  }
  
  action store_tag_content {
    printf("store_tag_content\n");
  }
  
  action store_pystring_content {
    printf("store_pystring_content\n");
  }
  
  action inc_line_number {
    parser->line_number += 1;
    printf("inc_line_number\n");
  }
    
  action last_newline {
    printf("last_newline\n");
  }
  
  action start_keyword {
    MARK(keyword_start, fpc);
    printf("start_keyword\n");
  }
  
  action end_keyword {
    MARK(keyword_end, fpc);
    MARK(body_start, fpc + 1);
    printf(" keyword found\n ");
  }
  
  action next_keyword_start {
    MARK(body_end, fpc);
    printf("next_keyword_start\n");
  }
  
  action end_table {
    //printf("end_table\n");
  }
 
  action end_feature {
    printf("end_feature\n");
  }

  include parser_common "parser_common.<%= i18n_language %>.rl";   

}%%

/** Data **/
%% write data;

int parser_init(parser *parser) {
  int cs = 0;
  %% write init;
  parser->cs = cs;
  parser->body_start = 0;
  parser->content_len = 0;
  parser->mark = 0;
  parser->nread = 0;
  parser->field_len = 0;
  parser->keyword_start = 0;
  parser->keyword_end = 0;
  parser->next_keyword_start = 0;
  parser->body_start = 0;
  parser->body_end = 0;
  parser->line_number = 1;
  
  return(1);
}

/** exec **/
size_t parser_scan(parser *parser, const char *buffer, size_t len, size_t off) {
  const char *p, *pe, *eof;
  int cs = parser->cs;

  assert(off <= len && "offset past end of buffer");

  p = buffer+off;
  pe = buffer+len;
  eof = pe;

  assert(*pe == '\0' && "pointer does not end on NUL");
  assert(pe - p == len - off && "pointers aren't same distance");

  %% write exec;

  parser->cs = cs;
  parser->nread += p - (buffer + off);
  
  assert(p <= pe && "buffer overflow after parsing execute");
  assert(parser->nread <= len && "nread longer than length");
  assert(parser->body_start <= len && "body starts after buffer end");
  assert(parser->mark < len && "mark is after buffer end");
  assert(parser->field_len <= len && "field has length longer than the whole buffer");
//  assert(parser->field_start < len && "field starts after buffer end");

// Reset parser (by re-initializing the whole thing) 
  parser_init(parser);
  
  return(parser_has_error(parser));
}

int parser_has_error(parser *parser) {
  return parser->cs == parser_error;
}
