%%{
  machine lexer;

  action begin_content {
    this.content_start = p;
    this.current_line = this.line_number;
    this.start_col = p - this.last_newline - (this.keyword+':').length;
  }

  action start_pystring {
    console.log('TODO: start_pystring');
  }
  
  action begin_pystring_content {
    console.log('TODO: begin_pystring_content');
  }

  action store_pystring_content {
    console.log('TODO: store_pystring_content');
  }

  action store_feature_content {
    p = this.store_keyword_content('feature', data, p, eof);
  }

  action store_background_content {
    p = this.store_keyword_content('background', data, p, eof);
  }

  action store_scenario_content {
    p = this.store_keyword_content('scenario', data, p, eof);
  }

  action store_scenario_outline_content {
    p = this.store_keyword_content('scenario_outline', data, p, eof);
  }

  action store_examples_content {
    p = this.store_keyword_content('examples', data, p, eof);
  }

  action store_step_content {
    console.log('TODO: store_step_content');
  }

  action store_comment_content {
    console.log('TODO: store_comment_content');
  }

  action store_tag_content {
    console.log('TODO: store_tag_content');
  }

  action inc_line_number {
    this.line_number++;
  }

  action last_newline {
    this.last_newline = p + 1;
  }

  action start_keyword {
    this.keyword_start = this.keyword_start || p;
  }

  action end_keyword {
    this.keyword = data.slice(this.keyword_start, p).toString('utf-8').replace(/:$/, '');
    this.keyword_start = null;
  }

  action next_keyword_start {
    this.next_keyword_start = p;
  }

  action start_row {
    console.log('TODO: start_row');
  }

  action begin_cell_content {
    console.log('TODO: begin_cell_content');
  }

  action store_cell_content {
    console.log('TODO: store_cell_content');
  }

  action store_row {
    console.log('TODO: store_row');
  }

  action end_feature {
    console.log('TODO: end_feature');
  }

  include lexer_common "lexer_common.<%= @i18n.underscored_iso_code %>.rl"; 
}%%

%% write data;
%% access this.;
%% variable data data;

var Lexer = function(listener) {
  this.listener = listener
  %% write init;
};

require('sys').inherits(Lexer, require('events').EventEmitter);

Lexer.prototype.scan = function(data) {
  var p = 0;
  var pe = data.length;
  var eof = 0;

  %% write exec;
};

Lexer.prototype.store_keyword_content = function(event, data, p, eof) {
  function unindent(startcol, text) {
    startcol = startcol || 0;
    return text.replace(new RegExp('^[\t ]{0,' + startcol + '}', 'gm'), ''); 
  }

  var end_point = (!this.next_keyword_start || (p == eof)) ? p : this.next_keyword_start;
  var content = unindent(this.start_col + 2, data.slice(this.content_start, end_point).toString('utf-8')).trimRight();
  var content_lines = content.split("\n")
  var name = content_lines.shift() || "";
  name = name.trim();
  var description = content_lines.join("\n");
  this.emit(event, this.keyword, name, description, this.current_line);
  var nks = this.next_keyword_start;
  this.next_keyword_start = null;
  return nks ? nks - 1 : p;
};

// TODO - get rid of this. We only keep this around to make it easier to test the lexer.
var fs = require('fs')
var lexer = new Lexer(null);

lexer.on('feature', function(keyword, name, description, line) {
  console.log(keyword + ': ' + name);
});
lexer.scan(fs.readFileSync(process.ARGV[2]));