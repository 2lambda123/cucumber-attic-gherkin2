module Gherkin
  module Parser
    class <%= i18n_parser_class_name %>
      %%{
        machine feature;
 
        action begin_content {
          @content_start = p
        }

        action begin_pystring {
          @lines = []
        }

        action start_pystring {
          start_col = p - @last_newline
          start = p + 4
        }

        action start_line {
          line_col = p - @last_newline
          line_start = p
        }

        action end_line {
          line = data[line_start...p].pack("c*")
          offset = line_col - start_col
          @lines << (offset >= 0 ? line.gsub(/^/, ' ' * offset) : line) 
        }
      
        action store_feature_content {
          if !@backup or (p==eof)
            con = data[@content_start...p].pack("c*")
          else
            con = data[@content_start...@backup].pack("c*")
          end
          con.strip!
          @listener.feature(@keyword, con, @current_line)
          if @backup
            p = @backup-1
          end
          @backup = nil
        }
      
        action store_background_content {
          if !@backup or (p==eof)
            con = data[@content_start...p].pack("c*")
          else
            con = data[@content_start...@backup].pack("c*")
          end
          @listener.background(@keyword, multiline_strip(con), @current_line)
          if @backup
            p = @backup-1
          end
          @backup = nil
        }
          
        action store_scenario_content {
          if !@backup or (p==eof)
            con = data[@content_start...p].pack("c*")
          else
            con = data[@content_start...@backup].pack("c*")
          end
          @listener.scenario(@keyword, multiline_strip(con), @current_line)
          if @backup
            p = @backup-1
          end
          @backup = nil
        }
        
        action store_scenario_outline_content {
          if !@backup or (p==eof)
            con = data[@content_start...p].pack("c*")
          else
            con = data[@content_start...@backup].pack("c*")
          end
          @listener.scenario_outline(@keyword, multiline_strip(con), @current_line)
          if @backup
            p = @backup-1
          end
          @backup = nil
        }
        
        action store_examples_content {
          if !@backup or (p==eof)
            con = data[@content_start...p].pack("c*")
          else
            con = data[@content_start...@backup].pack("c*")
          end
          @listener.examples(@keyword, multiline_strip(con), @current_line)
          if @backup
            p = @backup-1
          end
          @backup = nil
        }
      
        action store_step_content {
          con = data[@content_start...p].pack("c*")
          con.strip!
          @listener.step(@keyword, con, @current_line)
        }
        
        action store_comment_content {
          con = data[@content_start...p].pack("c*")
          con.strip!
          @listener.comment(con, @line_number)
        }
        
        action store_tag_content {
          con = data[@content_start...p].pack("c*")
          con.strip!
          @listener.tag(con, @current_line)
        }
  
        action store_pystring_content {
          if @lines == [""]  # Parser isn't grabbing newlines from 'empty' py_string
            (@line_number - @current_line -1).times { @lines << "" }
          end
          @listener.py_string(@lines.join("\n"), @current_line) 
        }

        action inc_line_number {
          @line_number += 1
        }
 
        action current_line {
          @current_line = @line_number
        }

        action start_keyword {
          @keyword_start ||= p
        }
 
        action end_keyword {
          @keyword = data[@keyword_start...p].pack("c*").sub(/:$/,'').strip
          @keyword_start = nil
        }
 
        action backup {
          @backup = p
        }
  
        action end_table {
          table_to_parse = '|' + data[@content_start...p].pack("c*").strip
          Gherkin::Parser::Table.new(@listener, @current_line).scan(table_to_parse)
          p = p-1
        }

        include feature_common "feature_common.<%= i18n_language %>.rl"; 
      }%%
  
      def initialize(listener)
        @listener = listener
        %% write data;
      end
  
      def scan(data)
        data = data.unpack("c*") if data.is_a?(String)
        @line_number = 1
        @last_newline = 0
        eof = data.size
        %% write init;
        %% write exec;
      end
 
      def multiline_strip(text)
        text.split("\n").map{|s| s.strip!}.join("\n")
      end
    end
  end
end
