module Gherkin
  module Parser
    class <%= i18n_parser_class_name %>
      %%{
        # patterns:
        # * data[start...end].pack("c*").strip_of_some_sort
        # * changing the end point of the range according to next_keyword_start
        # * methods taking the machine state because Ragel doesn't seem to know about ivars
 
        machine parser;
 
        action begin_content {
          @content_start = p
          @current_line = @line_number
        }

        action begin_pystring {
          @lines = []
        }

        action start_pystring {
          @current_line = @line_number
          start_col = p - @last_newline
          start = p + 4
        }

        action start_line {
          line_col = p - @last_newline
          line_start = p
        }

        action end_line {
          line = data[line_start...p].pack("c*")
          offset = line_col - start_col
          @lines << (offset >= 0 ? line.gsub(/^/, ' ' * offset) : line) 
        }
 
        action store_feature_content {          
          store_keyword_content(:feature, data, p, eof) { |con| con.strip }
          p = @next_keyword_start - 1 if @next_keyword_start          
          @next_keyword_start = nil
        }
 
        action store_background_content {
          store_keyword_content(:background, data, p, eof) { |con| multiline_strip(con) }
          p = @next_keyword_start - 1 if @next_keyword_start                    
          @next_keyword_start = nil
        }

        action store_scenario_content {
          store_keyword_content(:scenario, data, p, eof) { |con| multiline_strip(con) }
          p = @next_keyword_start - 1 if @next_keyword_start                    
          @next_keyword_start = nil
        }

        action store_scenario_outline_content {
          store_keyword_content(:scenario_outline, data, p, eof) { |con| multiline_strip(con) }
          p = @next_keyword_start - 1 if @next_keyword_start                    
          @next_keyword_start = nil
        }

        action store_examples_content {
          store_keyword_content(:examples, data, p, eof) { |con| multiline_strip(con) }
          p = @next_keyword_start - 1 if @next_keyword_start                    
          @next_keyword_start = nil
        }

        action store_step_content {
          con = data[@content_start...p].pack("c*").strip
          @listener.step(@keyword, con, @current_line)
        }
 
        action store_comment_content {
          con = data[@content_start...p].pack("c*").strip
          @listener.comment(con, @line_number)
        }
 
        action store_tag_content {
          con = data[@content_start...p].pack("c*").strip
          @listener.tag(con, @current_line)
        }
 
        action store_pystring_content {
          if @lines == [""]  # Parser isn't grabbing newlines from 'empty' py_string
            (@line_number - @current_line - 1).times { @lines << "" }
          end
          @listener.py_string(@lines.join("\n"), @current_line) 
        }
 
        action inc_line_number {
          @line_number += 1
        }
 
        action last_newline {
          @last_newline = p + 1
        }

        action start_keyword {
          @keyword_start ||= p
        }
 
        action end_keyword {
          @keyword = data[@keyword_start...p].pack("c*").sub(/:$/,'').strip
          @keyword_start = nil
        }
 
        action next_keyword_start {
          @next_keyword_start = p
        }
 
        action end_table {
          table_to_parse = '|' + data[@content_start...p].pack("c*").strip
          Gherkin::Parser::Table.new(@listener, @current_line).scan(table_to_parse)
          p = p - 1
        }

        action end_feature {
          if cs < parser_first_final
            raise ParsingError.new(@line_number)
          end
        }

        include parser_common "parser_common.<%= i18n_language %>.rl"; 
      }%%
 
      def initialize(listener)
        @listener = listener
        %% write data;
      end
 
      def scan(data)
        data = (data + "\n%_FEATURE_END_%").unpack("c*") # Explicit EOF simplifies things considerably
        eof = pe = data.length
 
        @line_number = 1
        @last_newline = 0
 
        %% write init;
        %% write exec;
      end
 
      def multiline_strip(text)
        text.split("\n").map{|s| s.strip}.join("\n").strip
      end
 
      def store_keyword_content(event, data, p, eof)        
        end_point = (!@next_keyword_start or (p == eof)) ? p : @next_keyword_start
        con = yield data[@content_start...end_point].pack("c*")
        @listener.send(event, @keyword, con, @current_line)
      end
    end
  end
end
