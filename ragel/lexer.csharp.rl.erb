namespace Gherkin.Lexer
{
	using System.Text;
	using System.Text.RegularExpressions;
	using System.IO;
	using System.Collections.Generic;
	using System.Linq;
	
	[Language("<%= @i18n.sanitized_key.downcase %>")]
	public class <%= @i18n.sanitized_key.capitalize %> : ILexer {
		%%{
			machine lexer;
			alphtype char;

			action begin_content {
				contentStart = p;
				currentLine = lineNumber;
			}

			action start_pystring {
				currentLine = lineNumber;
				startCol = p - lastNewline;
			}
		    
			action begin_pystring_content {
				contentStart = p;
			}

			action store_pystring_content {
				string con = Unindent(startCol, new Regex("(\\r?\\n)?( )*\\Z").Replace(Substring(data, contentStart, nextKeywordStart-1), "", 1));
				listener.PythonString(con, currentLine);
			}

			action store_feature_content {
				string con = MultilineStrip(KeywordContent(data, p, eof, nextKeywordStart, contentStart).Trim());
				listener.Feature(keyword, con, currentLine);
				if(nextKeywordStart != -1) p = nextKeywordStart - 1;
				nextKeywordStart = -1;
			}

			action store_background_content {
				string con = MultilineStrip(KeywordContent(data, p, eof, nextKeywordStart, contentStart));
				listener.Background(keyword, con, currentLine);
				if(nextKeywordStart != -1) p = nextKeywordStart - 1;
				nextKeywordStart = -1;
			}

			action store_scenario_content {
				string con = MultilineStrip(KeywordContent(data, p, eof, nextKeywordStart, contentStart));
				listener.Scenario(keyword, con, currentLine);
				if(nextKeywordStart != -1) p = nextKeywordStart - 1;
				nextKeywordStart = -1;
			}

			action store_scenario_outline_content {
				string con = MultilineStrip(KeywordContent(data, p, eof, nextKeywordStart, contentStart));
				listener.ScenarioOutline(keyword, con, currentLine);
				if(nextKeywordStart != -1) p = nextKeywordStart - 1;
				nextKeywordStart = -1;
			}

			action store_examples_content {
				string con = MultilineStrip(KeywordContent(data, p, eof, nextKeywordStart, contentStart));
				listener.Examples(keyword, con, currentLine);
				if(nextKeywordStart != -1) p = nextKeywordStart - 1;
				nextKeywordStart = -1;
			}

			action store_step_content {
				listener.Step(keyword, LookupStepKind(keyword), Substring(data, contentStart, p).Trim(), currentLine);
			}

			action store_comment_content {
				listener.Comment(Substring(data, contentStart, p).Trim(), lineNumber);
				keywordStart = -1;
			}

			action store_tag_content {
				listener.Tag(Substring(data, contentStart, p).Trim(), currentLine);
				keywordStart = -1;
			}

			action inc_line_number {
				lineNumber++;
			}

			action last_newline {
				lastNewline = p + 1;
			}

			action start_keyword {
				if(keywordStart == -1) keywordStart = p;
			}

			action end_keyword {
				keyword = new Regex(":$").Replace(Substring(data, keywordStart, p), "", 1);
				keywordStart = -1;
			}

			action next_keyword_start {
				nextKeywordStart = p;
			}

			action start_table {
				p = p - 1;
				rows = new List<IList<string>>();
				currentLine = lineNumber;
			}

			action start_row {
				currentRow = new List<string>();
			}

			action begin_cell_content {
				contentStart = p;
			}

			action store_cell_content {
				currentRow.Add(Substring(data, contentStart, p).Trim());
			}

			action store_row {
				rows.Add(currentRow);
			}

			action store_table {
				if(rows.Count > 0) {
					listener.Table(rows, currentLine);
				}
			}

			action end_feature {
				if(cs < lexer_first_final) {
					string content = CurrentLineContent(data, lastNewline);
					throw new LexingException("Lexing error on line " + lineNumber);
				}
			}

			include lexer_common "lexer_common.<%= @i18n.sanitized_key %>.rl"; 
		}%%

		private readonly IListener listener;

		private static readonly IDictionary<string, StepKind> stepKeywords = new Dictionary<string, StepKind>();

		static <%= @i18n.sanitized_key.capitalize %>()
		{
			<% @i18n.keywords('given', true).reject{|kw| kw == '* '}.each do |keyword| %>
			stepKeywords["<%=keyword%>"] = StepKind.Given;
			<% end %>
			<% @i18n.keywords('when', true).reject{|kw| kw == '* '}.each do |keyword| %>
			stepKeywords["<%=keyword%>"] = StepKind.When;
			<% end %>
			<% @i18n.keywords('then', true).reject{|kw| kw == '* '}.each do |keyword| %>
			stepKeywords["<%=keyword%>"] = StepKind.Then;
			<% end %>
			<% @i18n.keywords('and', true).reject{|kw| kw == '* '}.each do |keyword| %>
			stepKeywords["<%=keyword%>"] = StepKind.And;
			<% end %>
			<% @i18n.keywords('but', true).reject{|kw| kw == '* '}.each do |keyword| %>
			stepKeywords["<%=keyword%>"] = StepKind.But;
			<% end %>
			stepKeywords["* "] = StepKind.Any;
		}

		private static StepKind LookupStepKind(string keyword)
		{
			if (!stepKeywords.Keys.Contains(keyword))
			   return StepKind.Unknown;
			return stepKeywords[keyword];
		}

		public <%= @i18n.sanitized_key.capitalize %>(IListener listener) {
			this.listener = listener;

		}

		%% write data noerror;

		public void Scan(TextReader inputSequence) {
			string input = inputSequence.ReadToEnd() + "\n%_FEATURE_END_%";
			char[] data = Encoding.GetEncoding("iso-8859-1").GetChars(Encoding.UTF8.GetBytes(input));
			int cs, p = 0, pe = data.Length;
			int eof = pe;

			int lineNumber = 1;
			int lastNewline = 0;

			int contentStart = -1;
			int currentLine = -1;
			int startCol = -1;
			int nextKeywordStart = -1;
			int keywordStart = -1;
			string keyword = null;
			IList<IList<string>> rows = null;
			IList<string> currentRow = null;

			%% write init;
			%% write exec;
		}

		private string KeywordContent(char[] data, int p, int eof, int nextKeywordStart, int contentStart) {
			int endPoint = (nextKeywordStart == -1 || (p == eof)) ? p : nextKeywordStart;
			return Substring(data, contentStart, endPoint);
		}

		private string MultilineStrip(string text) {
			var result = new StringBuilder();
			foreach (var s in text.Split(new [] {'\n'})) {
				result.AppendLine(s.Trim());
			}
			return result.ToString().Trim();
		}

		private string Unindent(int startCol, string text) {
			return new Regex("^ {0," + startCol + "}", RegexOptions.Multiline).Replace(text, "");
		}

		private string CurrentLineContent(char[] data, int lastNewline) {
			return Substring(data, lastNewline, data.Length).Trim();
		}

		private string Substring(char[] data, int start, int end) {
			return Encoding.UTF8.GetString(Encoding.GetEncoding("iso-8859-1").GetBytes(data, start, end-start));
		}
	}
}
